name: docker-publish

on:
  push:
    branches: [ "**" ]
    tags: [ "v*.*.*" ]  
  pull_request:
    types: [ opened,synchronize ]
    branches: [ "master" ]
  workflow_dispatch:  # 允许手动触发该工作流

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Docker meta
        id: meta  # 给步骤设置 ID，方便后续步骤引用输出
        uses: docker/metadata-action@v5
        with:
          images: registry.cn-hangzhou.aliyuncs.com/dongjun11/flask-demo  # 打包后的容器镜像名
          tags: |
            type=ref,event=branch  # 基于分支名生成标签
            type=semver,pattern={{version}}  # 基于语义化版本标签生成完整版本号（如v1.2.3对应的标签为1.2.3）
            type=sha  # 基于Git提交哈希生成标签

      - name: Login to Aliyun Container Registry
        if: github.event_name != 'pull_request'  # 只有当触发事件不是PR时才执行，即如果为PR事件则不会登录
        uses: docker/login-action@v3
        with:
          registry: registry.cn-hangzhou.aliyuncs.com  # 远程仓库登录地址
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3  # 使用QEMU插件，解决架构兼容性问题，使不同架构的镜像构建成为可能

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3  # 使用Buildx插件提供高级构建功能，优化构建流程和性能

      - name: Build and push
        id: build  # 给构建步骤添加ID，方便后续引用
        uses: docker/build-push-action@v6  # 因为该插件是基于Buildx构建镜像的所以需要上面的步骤，且会自动克隆仓库到当前工作环境中
        with:
          push: ${{ github.event_name != 'pull_request' }}  # 仅当非PR事件时才推送镜像，即PR事件只构建镜像不推送
          tags: ${{ steps.meta.outputs.tags }}  # 使用步骤1生成的标签（从 meta 步骤的输出中获取）
          load: true  # 将构建的镜像加载到本地Docker守护进程（默认Buildx构建后不加载到本地，需手动开启）
          cache-from: type=gha  # 优化构建缓存
          cache-to: type=gha,mode=max  # 优化构建缓存

      - name: Print image ID and size  # 查询并打印镜像ID和大小
        if: github.event_name != 'pull_request'  # 仅推送后执行
        run: |
          # 获取镜像标签
          IMAGE_TAGS=$(echo "${{ steps.meta.outputs.tags }}" | tr '\n' ' ')
          IMAGE_TAG=$(echo "$IMAGE_TAGS" | awk '{print $1}')  # 取第一个标签（如 master 或 v1.2.3）
          
          echo "=== 镜像基本信息 ==="
          echo "镜像标签（当前查询）: $IMAGE_TAG"
          echo "所有镜像标签: $IMAGE_TAGS"
          
          # 关键修复2：检查镜像是否存在（避免本地无镜像的报错）
          if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^$IMAGE_TAG$"; then
            echo "错误：本地未找到镜像 $IMAGE_TAG"
            exit 1
          fi
          
          # 1. 打印本地 Image ID
          echo -e "\n=== 本地镜像ID（Image ID） ==="
          IMAGE_ID=$(docker inspect --format '{{ .Id }}' "$IMAGE_TAG" 2>/dev/null)
          echo "Image ID: $IMAGE_ID"
          
          # 2. 打印镜像大小（格式化显示，兼容所有场景）
          echo -e "\n=== 镜像大小 ==="
          IMAGE_SIZE_BYTES=$(docker inspect --format '{{ .Size }}' "$IMAGE_TAG" 2>/dev/null)
          IMAGE_SIZE_MB=$((IMAGE_SIZE_BYTES / 1024 / 1024))
          IMAGE_SIZE_GB=$(echo "scale=2; $IMAGE_SIZE_BYTES / 1024 / 1024 / 1024" | bc)  # 可选：显示GB
          echo "原始大小: $IMAGE_SIZE_BYTES 字节"
          echo "格式化大小: $IMAGE_SIZE_MB MB / $IMAGE_SIZE_GB GB"
          
          # 3. 打印远程 Digest（兼容空值，避免报错）
          echo -e "\n=== 远程镜像Digest（推送后） ==="
          # 使用 if 语句判断 RepoDigests 是否为空，避免索引越界
          DIGEST=$(docker inspect --format '{{ if gt (len .RepoDigests) 0 }}{{ index .RepoDigests 0 }}{{ else }}未获取到（可能推送未完成或镜像未关联远程）{{ end }}' "$IMAGE_TAG" 2>/dev/null)
          echo "Digest: $DIGEST"
